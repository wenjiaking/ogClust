% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ogClust_GM.R
\name{ogClust_GM}
\alias{ogClust_GM}
\title{Title Fit ogClust_GM mixture model embedding the multinomial logistic regression and with continuous outcome}
\usage{
ogClust_GM(
  n,
  K,
  np,
  NG,
  lambda,
  alpha,
  G,
  Y,
  X,
  theta_int,
  robust = "none",
  tau = 1.345
)
}
\arguments{
\item{n}{an integer defines number of samples}

\item{K}{an integer defines the number of subgroups}

\item{np}{an integer defines the number of covariates}

\item{NG}{an integer defines the number of features of omics data}

\item{lambda}{the regularization tuning parameter for sparsity}

\item{alpha}{the L2 regularization tuning parameter}

\item{G}{the matrix for omics data. The rows are samples and columns are features.}

\item{Y}{the vector of a single outcome}

\item{X}{the vector of covariates}

\item{theta_int}{initial values of parameters}

\item{robust}{the robust method to be used in fitting the model.
The default \code{"none"} do not use any robust estimation method.
\code{robust = "huber"} uses Huber loss with fixed cutoff \code{tau}.
\code{robust = "hubertf"} uses adaptive Huber loss, and \code{"median"} uses median-truncated
loss  in model fitting.}

\item{tau}{a single \code{numeric} value. Defines the boundary where the loss function transit
from quadratic to linear if argument \code{robust = "huber"}. Defualt is \code{1.345}.}
}
\value{
An object with class \code{"ogClust"}
\itemize{
\item{\code{par}}{ a list of parameter estimates}
\item{\code{ll}}{likelihood}
\item{\code{AIC}}{AIC}
\item{\code{BIC}}{BIC}
\item{\code{lambda}}{lambda}
\item{\code{Y_prd}}{ predicted outcome}
\item{\code{grp_assign}}{ prediced group assignement}
}
}
\description{
Title Fit ogClust_GM mixture model embedding the multinomial logistic regression and with continuous outcome
}
\details{
The ogClust_GM is a unified latent generative model to perform clustering constructed
from omics data \code{G} with the guidance of outcome \code{Y}, and with covariate \code{X} to account for
the variability that is not related to subgrouping. A modified EM algorithm is applied for
numeric computation such that the liklihood is maximized. A posterior probability is obtain
for each subject belonging to each cluster.

ogClust_GM method performs feature selection, latent subtype characterization and outcome prediction simultaneously.
We use either LASSO penalty or LASSO penalty plus L2 regularization( \eqn{lambda*(L1 + alpha*L2)})
Parameter \code{lambda} is the penalty tuning parameter, and \code{alpha} tunes the L2 regularization. To account for possible
outliers or violation of mixture Gaussian assumption, we incorporate robust
estimation using Huber loss (Huber, 2004), adaptive Huber (Wang et al., 2020) or median-truncated loss function (Chi et al., 2019).
Use argument \code{robust} to select the robust estimation method to be used in model fitting. If \code{robust = "huber"},
we need to set another parameter \code{tau} controlling the boundary of linear and quadratic loss. The choice of best \code{tau}
depends on data.
}
\examples{
\dontrun{
  data('GSE47460_GPL14550') #load lung dataset

  # extract gene expression G, covariate X, outcome Y
  G=GSE47460_GPL14550$Expression
  X=GSE47460_GPL14550$Covariates
  Y=GSE47460_GPL14550$outcome
  g.mean<-apply(G,1,mean)
  cut.mean=quantile(g.mean,probs=0.5)
  G=G[g.mean>cut.mean,] # remove 50\% lowest mean expression genes
  g.sd=apply(G,1, sd)
  cut.sd=quantile(g.sd,probs=0.5)
  G=G[g.sd>=cut.sd,] # further remove 50\% lowest variance genes
  G<-t(G)
  G<-scale(G)
  # number of subjects
  n=nrow(G)
  # number of genes
  NG=ncol(G)
  # number of covariates
  np=ncol(X)
  # number of clusters
  K=3
  # tuning parameter
  lambda=0.001

  # set initial values
  beta_int = runif(np, 0, 3)
  gamma_int = runif((K - 1) * (NG + 1), 0, 1)
  beta0_int = runif(K, 0, 3)
  sigma2_int = runif(1, 1, 3)
  theta_int = c(beta_int, gamma_int, beta0_int, sigma2_int)

  # fit ogClust
  fit.res<-ogClust_GM(n=n, K=K, np=np, NG=NG, lambda=lambda,
                    alpha=1, G=G, Y=Y, X=X,theta_int=theta_int)
}
}
