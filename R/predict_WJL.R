#' @title Get the predicted cluster label and predicted outcome using the gene expression of validation dataset and the ogClust_WJL model from training data
#' @param mod ogClust model from discovery/training data, generated by ogClust() or ogClust.surv()
#' @param K Number of clusters
#' @param D.test Gene expression of validation/testing data (n*p matrix)
#' @param X1 covariate matrix of discovery/training data (n*q matrix)
#' @param p number of genes
#' @return a list with five components
#' \itemize{
#' \item{y.pred: }{predicted outcome using soft assignment}
#' \item{clus: }{predicted cluster label}
#' \item{index: }{Indicate the position of informative genes in the training model}
#' \item{Y.hard: }{predicted outcome using hard assignment}
#' \item{z_est: }{predicted cluster probability (n*K matrix)}
#' }
#' @export
#'
#' @examples
#' \dontrun{
#' #input the weight and lambda
#' s_G<-200
#' w<-0.727
#' w<-(s_G*w)/(s_G*w+1-w)
#' lambda<-8
#'
#' #------------------------select top 2000 genes using marginal screening
#' t.stat<-rep(NA,nrow(GSE47460_GPL6480$expression))
#' for(i in 1:nrow(GSE47460_GPL6480$expression)){
#'  data<-data.frame(y=GSE47460_GPL6480$outcome,x=GSE47460_GPL6480$expression[i,])
#'  mod<-lm(y ~ x, data = data)
#'  mod<-summary(mod)
#'  t.stat[i]<-mod$coefficients[2,3]
#'}
#'Index<-order(abs(t.stat),decreasing = T)
#'x<-GSE47460_GPL6480$covariates
#'G<-GSE47460_GPL6480$expression[Index[1:2000],]
#'y<-GSE47460_GPL6480$outcome
#'
#'#get the intial cluster center
#'mod.kmeans<-kmeans(t(G),centers = 3,nstart = 20)
#'center<-t(mod.kmeans$centers)
#'x<-as.matrix(x)
#'
#'#implement ogClust
#'mod = ogClust(x=x,G=G,y=y,c_center=center,
#'              lambda=lambda,v_int=NULL,pi_int=NULL,K=3,max_iter=200,w_outcome=w,w_G=1-w,z_int=NULL)
#' #predict for the validation data
#' G.test<-GSE47460_GPL14550$expression
#' X.test<-GSE47460_GPL14550$covariates
#' index<-match(rownames(G),rownames(G.test))
#' G.test<-G.test[index,]
#' mod.predict<-predict_test(mod,K = 3,D.test =t(G.test),X1 =X.test, p = nrow(G))
#'}

predict_test<-function(mod,K,D.test,X1,p=p){
  mult_density1<-function(x,mu,sigma){
    lik<-dnorm(x,mean=mu,sd=sqrt(sigma),log=TRUE)
    return(lik)
  }
  mu_est<-mod$result_list$mu
  pi_est<-mod$result_list$pi
  sigma_est<-mod$result_list$sigma
  coef_est<-mod$result_list$int_coef
  if(ncol(D.test)>1){
    D.test<-t(D.test)
  }
  #p<-ncol(D.test)
  #D.test<-t(D.test)
  #D.test<-as.matrix(D.test)
  mult_pdf<-matrix(,nrow=ncol(D.test),ncol=K)
  #------------------------------each sample in each cluster (sum of log likelihood)
  for(j1 in 1:K){
    temp<-mult_density1(as.numeric(D.test),mu=rep(mu_est[,j1],times=ncol(D.test)),sigma=rep(sigma_est,times=ncol(D.test)))
    temp_matrix<-matrix(temp,nrow=p,ncol=ncol(D.test),byrow=FALSE)
    mult_pdf[,j1]<-t(temp_matrix)%*%rep(1,p)
  }
  #---------------------get the predicted probability for each sample
  max_pdf<-apply(mult_pdf,1,max)
  max_pdf_matrix<-matrix(rep(max_pdf,times=K),ncol=K)
  mult_pdf1<-mult_pdf-max_pdf_matrix
  mult_pdf2<-exp(mult_pdf1)*matrix(rep(pi_est,times=ncol(D.test)),byrow=T,ncol=K)
  sum_mult_pdf2<-mult_pdf2%*%rep(1,K)
  z_est<-mult_pdf2/matrix(rep(sum_mult_pdf2,times=K),ncol=K)
  beta_vector<-coef_est[1:K]

  if(nrow(z_est)==1){
    y.pred<-t(as.matrix(X1))%*%as.matrix(coef_est[(K+1):length(coef_est)])+ z_est%*%beta_vector
  }else{
    y.pred<-as.matrix(X1)%*%as.matrix(coef_est[(K+1):length(coef_est)])+ z_est%*%beta_vector
  }
  cluster<-apply(z_est,1,which.max)
  intercept<-rep(NA,nrow(X1))
  for(i in 1:K){
    intercept[which(cluster==i)]<-beta_vector[i]
  }
  y.pred.hard<-as.matrix(X1)%*%as.matrix(coef_est[(K+1):length(coef_est)])+intercept



  # cluster<-apply(mod$result_list$z,1,which.max)
  # G.mean<-matrix(NA,nrow=ncol(D.train),ncol=K)
  # for(i in 1:K){
  #   G.mean[,i]<-as.numeric(apply(D.train[which(cluster==i),],2,mean))
  # }
  #
  index<-which(apply(mod$result_list$mu,1,function(x){length(unique(x))})!=1)
  # G.pred<-as.matrix(G.mean)%*%as.matrix(t(z_est))
  if(nrow(z_est)==1){
    clus<-which.max(z_est)
  }else{
    clus<-apply(z_est,1,which.max)
  }
  #clus<-which.max(z_est)
  y.pred.hard
  #res<-list(Y=y.pred,G=G.pred,clus=clus,index=index)
  res<-list(Y=y.pred,clus=clus,index=index,Y.hard=y.pred.hard,z_est=z_est)
  return(res)
}

